package tourney;

import java.util.ArrayList;
import java.util.List;

/**
 * A Game incorporates the rules of play for some particular board game.
 * Possibly will be expanded to include other sorts of games in future Games do
 * not necessarily include any provision for interactive play; they are
 * primarily intended to run CPU vs. CPU competitions.
 */
public abstract class Game
{
	
	/** 
	*	A list of all the players in the game, available for implementations. 
	*/
	protected List<Player> activePlayers;
	
	/**
	 * The current record of the Game. This must be instantiated to the proper
	 * type by the implementation in init() or the Game won't play.
	 */
	protected GameResult gameResult;
	

	/**
	 * Based on these players, play through the game, and return a Result (In
	 * particular, a GameResult) that depicts a record of the Game.
	 * 
	 * @throws IllegalMoveException
	 */
	public GameResult play(List<Player> players)
			throws IllegalMoveException, GameExecutionException
	{
		// Ensure that players is initialized before we enter init()
		this.activePlayers = new ArrayList<Player>(players);

		init();

		if (gameResult == null)
		{
			abort(getName() + " does not instantiate gameResult"
					+ " in init() like it's supposed to.");
		}   // JPK: This should be handled by unit testing of submitted Games
			//instead. A Game that doesn't pass this shouldn't even play

		while(keepGoing())
		{
			prePoll();
			poll();
			process();
			updateEachPlayer(players);
			postUpdate();
			record();
		}
		return gameResult;
	}

	/* Hook Methods in Order of Appearance in play() */

	/**
	 * A pre-game-loop hook method called before the Game starts. All setup code
	 * can go here for the Game.
	 * 
	 * Be aware! Implementations should instantiate gameResult to the necessary
	 * type, in place of the default. However, if implementations override
	 * init(), they must be sure to instantiate a gameResult, otherwise they
	 * must call super.init()
	 */
	protected void init()
	{
	}

	/**
	 * A hook provided in case it is necessary to perform actions each iteration
	 * before the game polls any players for their move.
	 * 
	 * An example might be to tell the player the new weights for this round in
	 * an IPD Game.
	 */
	protected void prePoll()
	{
	}

	/**
	 * A hook method for allowing Games to poll any Players for Moves before
	 * processing any Data.
	 * 
	 * This is where you call player.getMove(), and check for legality. Throw
	 * IllegalMoveException if any Moves are illegal.
	 */
	protected void poll() throws IllegalMoveException
	{
	}

	/**
	 * A hook method that is called after the game polls any Players. Any
	 * processing of the data should go here.
	 * 
	 * An example might be updating the game's version of the state or
	 * annotating the moves for the game record.
	 */
	protected void process()
	{
	}

	/**
	 * A hook method that is designed to tell all players what happened for this
	 * iteration.
	 */
	protected void updateEachPlayer(List<Player> players)
	{
	}

	/**
	 * A hook method that is executed after players are updated. Included on the
	 * off chance that we want to allow something to happen here. Can't think of
	 * a use case just now. Will remove if we can't think of a reason to keep
	 * it.
	 */
	protected void postUpdate()
	{
	}

	/**
	 * A hook method that is called so the implementation may update the game record.
	 */
	protected void record()
	{
	}
	
	/**
	 * A method games can call if it is necessary to abort their game. This flag
	 * will not be checked until the end of an iteration in play(). Games should
	 * ensure that Methods between when this is called and the next iteration do
	 * not hang up execution. A GameExecutionException will be thrown with the
	 * specified reason.
	 */
	protected final void abort(String reason) throws GameExecutionException {
		throw new GameExecutionException(reason);
	}

	/* Unimplemented Methods */

	/**
	 * A Game must determine if the Move generated by a player is legal. Illegal
	 * can be defined as "an unforgivable mistake" and the player will be kicked
	 * out of the Tournament. There is no mechanism for giving the player a
	 * second chance for coming up with a correct Move, as we are dealing with
	 * AI most of the time, therefore if the Game cannot handle the Move without
	 * needing to ask the player for another Move, the Move is by definition,
	 * Illegal.
	 */
	protected abstract boolean isLegal(Move move);

	/**
	 * It is up to the implementation to tell us whether the Game should
	 * continue to execute or not.
	 */
	protected abstract  boolean keepGoing();

	/* Public Interface Methods */

	/**
	 * We suggest that game developers provide a very basic "AI" for testing.
	 * The default AI must generate legal moves, but they need not be good ones.
	 * Random is fine. If no default AI player is provided, defaultAIPlayer
	 * should be set to null.
	 */
	public abstract Player getDefaultAIPlayer();

	/**
	 * We also suggest that game developers provide a human interface, also for
	 * testing. If none is provided, humanPlayer should be null.
	 */
	public abstract Player getHumanPlayer();

	/**
	 * Return the necessary DataReader capable of interpreting statistics
	 * generated from playing this Game.
	 */
	public abstract DataReader getDataReader(TournamentResult result);

	/**
	 * The name of the Game.
	 */
	public abstract String getName();

	/**
	 * Who wrote/designed this Game.
	 */
	public abstract String getAuthor();

	/**
	 * Each game should define how many players it needs as a parameter to
	 * play(). Users of this interface should ensure that the list of players
	 * passed to play() is the size of this return value.
	 */
	public abstract int playersPerGame();
}
