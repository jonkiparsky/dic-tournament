= How to Use the API to Write Game and Player Implementations =
This article is intended to give someone not familiar with our code a basic idea on how that person may write a Game or Player class that can conform with the API.

= Writing a Game Implementation =
== Getting Familiar With How Game Works ==
If you would like to write a Game for our API, the first thing you should do is become familiar with the Game class by consulting the javadoc. Once you are familiar with some of the methods and fields, you may start to see some patterns in how Game is set up. If not, I will explain them briefly here.

Game provides "hook" methods which it calls at certain stages of it's play method. The first such method is `init`. This method allows an implementation of Game to override it, and perform any setup code that it needs to do before the game loop is started. Once the game loop is started, the game will call various methods in a loop. The order is as follows:

  # *prePoll* - this method is called at the beginning of each iteration.
  # *poll* - this method is called next. Games should demand moves from the players here.
  # *process* - this method is called to process the moves retrieved from the players
  # *updateEachPlayer* - this method is called to give the game a chance to update the players
  # *postUpdate* - this method is called after updateEachPlayer to give Game the chance to do anything it needs to before record is called.
  # *record* - this method is called so the Game can record what happened for this iteration.

One thing to remember is that the Player interface provides an update() method to keep the Player's state updated. Our API specifies that each Player must maintain its own state of the Game. This makes cheating or trying to alter the Game's state impossible. It also ensures that the Player must have some knowledge about the rules of the Game, so it is more likely they can provide a legal move. However, this puts the added responsibility on the Game to update each Player with Moves, even if it is the Move they just submitted. Game's should also maintain their own version of the state. Players who fall out of sync will start to submit invalid moves and will be dealt with by Game's security measures.

== Beginning to Write Your Game ==
The first thing you should do when writing your Game is to determine the game format and find any pre-written classes that further refine the rules of Game to the specific format. The API provides a couple pre-written common formats. If you find one that suits your game, this means less work for you.

The Game class is just a place where the actual game progresses. There is no restriction on how many classes you can use. You can write as many helper classes as you want to aid you. In fact it is recommended that you do so. Just place all the files in the same package. With that in mind, if you wrote a game program, but didn't write it for this implementation, you should be able to re-use many of the classes, and only have to fiddle with fitting it into our Game class.

== The Required Classes ==
There are a few API classes you will need extend though in order to have a functional game.

  * *Move* - You must extend Move if you want the Player to be able to tell you anything. Your subclass should provide all the necessary methods to hold the data needed for a move in your Game. Player implementations of you Game will be using this, so try to make it user-friendly.
  * *GameResult* - You must extend GameResult if you want to record any useful statistics. Since different Games will have very specific statistics, it is up to you to design a result class that will be able to aggregate the necessary statistics. Fortunately, you will be the one interacting with the statistics (see the next item).
  * *DataReader* - The API has no knowledge of what type of statistics you keep track of in your Game. Therefore, it is up to you to design a DataReader for your Game that will be able to handle the Results from your GameResult class and give a coherent report.
  * *Player* - Although creating Player implementations for your game is not required, we recommend that you do. If you create a partial implementation that has all of the necessities needed to play your Game, then you will make it easier for people writing Player implementations for your Game.

The API specifies that each Game should have two default Player implementations. One should be an artificial intelligence that generates legal moves, and the other should be an interactive implementations so that humans can play. While our API is not designed for human play, you can imagine how useful it will be to have one for testing purposes. You will probably need to write these to test your Game anyway.

= Writing a Player Implementation =
If you would like to write a Player implementation for a Game, you first need to be familiar with the interface. Have a look at the javadoc for the Player class. Once you are familiar with the interface, you need to see if the Game you are writing this for has any base Player implementations that you can extend to make your life easier. If it does, then you are in luck. Otherwise, you'll have to write the necessary code yourself.

== The Player interface ==
The Player interface is simple. You need to provide a legal Move object for the Game you are playing whenever getMove() is called. The rest of the interface stems from that.

So how do you know what the proper move to make is when getMove() is called? You aren't given any information as to the state of the Game. Well, that's where the other interface method comes into play. Player objects are responsible for maintaining their own version of the Game state. The Game will be responsible for calling your `update(Move)` method to keep your state up to date. Your implementation of update() should change your state based on the move passed to it. If you are lucky, the Game you are writing your implementation for may have provided a base Player class that handles the state for you.

*Note*: Do not try to change the state of your game from within the getMove() method. Only ever change it from update, and never call update yourself. Game will send you your own move through update. If you attempt to change it yourself in getMove(), your state could fall out of sync and you may start producing illegal moves and be disqualified.

== Required Classes ==
You do not need to write any other classes unless you want to write some to help with your artificial intelligence decision making. You do need to use or be familiar with a couple classes other than Player though.

The obvious one is Move. Specifically, your game's implementation of Move. You will need to instantiate a new Move object with your intentions in order to send it back to Game. You should familiarize yourself with this class. Again, if you are lucky, the base Player for your game may provide a user-friendly way of generating the proper Move.

The other classes you will need to be familiar with are the Game's classes that it uses to maintain the state. For example, if your writing a chess player, you may need to use the game's Board and Piece classes to help you represent the board.

The rest falls onto your shoulders. That's the fun part. Once you understand all of the classes you need to know, writing the decision making is the fun part.